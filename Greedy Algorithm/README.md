# Greedy Algorithms (2020.04.16) (2020.09.09)

# 1차시. 탐욕 알고리즘

: 최적화 문제를 해결하는 알고리즘으로 근시안적 방법이다

-   그 순간 최적이라고 생각되는 것을 선택해 나가는 방식으로 최종적인 해답에 도달함
-   한 번 선택된 것은 번복하지 않음
-   탐욕 알고리즘은 단순하며 제한적인 문제들에 적용됨
-   각 결정은 지역적으로는 최적이나, 선택을 계속 수집하여 해답을 만들었으므로 그것이 최적이라는 보장은 없음
-   **따라서 그리디 알고리즘을 적용시 이 해가 항상 최적해임을 증명해야 함**

### 최적화 문제란?

: 최적(최대값이나 최소값 등)값을 구하는 문제로 하나의 문제에 여러 해가 있을 수 있음(즉 The 최적해가 아닌, an 최적해를 구하는 것)

## 해 선택

1.  부분 문제의 최적해를 구해 부분 해 집합에 추가함
2.  현재 상태에서 최선이라고 여겨지는 선택을 추가함
3.  실행 가능성 검사
4.  새로운 부분 해 집합의 실행 가능 여부 확인

-   문제의 제약 조건 위반 여부 검사

5.  해 검사
6.  새로운 부분 해 집합이 문제의 해가 되는지 확인

**전체 문제의 해가 완성되지 않은 경우 해 선택부터 다시 시작**

# 2차시. 동전 거스름돈 문제

## 1) 소개

### 거스름돈을 지급하는 방법

: 거스름돈의 개수를 최소한으로 줄 수 있는 방법은?

## 2) 탐욕 기법 적용

1.  해 선택

-   전략 : 가장 좋은 해 선택
-   방법 : 단위가 큰 동전순으로 거스름돈 만들기

2.  실행 가능성 검사

-   방법 : 거스름돈이 손님에게 내드려야 할 액수를 초과하는지 확인
-   초과한다면 추가한 동전을 빼고 해 선택으로 돌아가 한 단계 작은 동전을 추가함

# 3차시. 배낭 문제

## 1) 소개

### 훔친 물건을 배낭에 담는 방법

: 배낭의 무게를 초과하지 않으면서 물건값이 최대가 되도록 담는 방법

### 배낭 문제의 정형적 정의

: **Σ(item.i∈A)W.i <= W , Σ(item.i∈A)P.i**

-   의미: 물건들의 무게의 합이 배낭무게를 초과하지 않고 물건값이 최대가 되도록 A를 결정
-   S : n개의 물건들의 집합
-   Wi : i번 째 물건의 무게
-   Pi : i번 째 물건의 값(가치)
-   W : 배낭에 수용 가능한 총 무게

### 배낭 문제의 종류

1.  0-1 Knapsack

-   배낭에 물건을 통째로 담아야 하는 문제
-   물건을 쪼갤 수 없는 경우임

2.  Fractional Knapsack

-   물건을 부분적으로 담는 것이 허용
-   물건을 쪼갤 수 있는 경우

## 2) 탐욕 기법 적용

### 0-1 Knapsack에 대한 탐욕적 방법

1.  전략1 : 값이 비싼 물건부터 채운다
2.  전략2 : 무게가 가벼운 물건부터 채운다
3.  전략3 : 무게당 값이 높은 순서로 물건을 채운다

**전략 1,2,3 다 최적해를 구할 수 없음, 즉 탐욕적 방법으로 배낭문제의 최적해를 구한다는 보장을 할 수 없음**

### Fractional Kanpsack 방법
- 전략 : 물건의 일부를 잘라서 담을 수 있다
- 실생활에서 사용할 수 있는 방법은 아니나 이상적으로 구할 수 있는 최대 가치임
**해당 전략으로 최적해를 구할 수 있음**

# 4차시. 활동 선택 문제

## 1) 소개
: 회의실을 배정하는 방법에 대해 생각해보자
- 단, 회의는 시작과 종료 시간이 정해져 있으며 동시에 2개 이상의 회의가 열릴 수 없음

## 2) 탐욕 기법 적용
### 회의실 배정 문제
- 시작시간과 종료시간이 있는 n개의 활동들의 집합에서 서로 겹치지 않는 최대 개수의 활동들의 집합을 구하는 문제
- 양립 가능한 활동들의 크기가 최대가 되는 부분집합을 선택하는 문제

### 탐욕 기법의 적용
- 전략 : 종료 시간이 가장 빠른 활동 순으로 선택

### 탐욕 기법의 적용 방법
1. 탐욕적 선택
- 최선의 선택 : 종료 시간이 가장 빠른 활동 순으로 선택
- 항상 최적의 해 구할 수 있음
2. 탑다운 방식의 문제 해결

### 탐욕 기법을 적용한 반복 알고리즘
```
//일을 종료시간이 빠른 순으로 정렬(단, 종료시간이 같을 경우 시작시간이 빠른 순으로 정렬)
sort(work.begin(), work.end(), compare); 
int tmp = work[0].second; //제일 종료시간이 빠른애로 스타트
int ans = 1; //총 가능한 회의 갯수

for(int i = 1; i < total_work; i++){
	//현재 진행하고 있는 회의가 종료되는 시간과 같거나 이후에 시작하는 일 고르기
	if( w[i].first >= tmp){
    	ans++;
        tmp = w[i].second; //고른 일의 종료시간을 저장
    }
```

## 3) 탐욕 기법과 동적 계획법의 비교
|     탐욕 기법                                  |                    동적 계획법                      |  
| :------------------------------------------: | :----------------------------------------------: |
| 단계마다 가장 좋아 보이는 것을 선택함 -> 지역 최적 선택  | 매 단계의 선택은 해결한 하위 문제의 해를 기반으로 함  |  
| 하위 문제 풀기 전, (탐욕적) 선택이 먼저 이루어짐  | 하위 문제 우선 해결 | 
| 탑-다운 방식  | 바텀-업 방식  |
| 일반적으로, 빠르고 간결함 | 좀 더 느리고, 복잡함 | 


### Activity Selection Problem
* 1931번.회의실 배정 <https://www.acmicpc.net/problem/1931>


### etc
* 1969번.DNA <https://www.acmicpc.net/problem/1969>
* 5585번.거스름돈 <https://www.acmicpc.net/problem/5585>
